#!/usr/bin/env perl

use strict;
use warnings;

my %filetable;
my $pwd;
my $srcdir;

BEGIN {
	die qw/You cannot invoke this script that way !/ if(__FILE__ =~ /-e/);
	# this is used to dynamically set Perl module path.
	$srcdir = `readlink -e \`dirname $0\``; chomp $srcdir;
	$pwd = $srcdir;
	$srcdir .= "/../..";
}

#third-party libs loading
use lib "$srcdir/build_scripts/modules";

use File::Basename;
use Data::Dumper;
use JSON;
use YAML qw(DumpFile);

sub retrieve_file_specs {
	my ($file) = @_;
	open my $fh, "<", $file;
	my %annotations;
	while(<$fh>)
	{
		if("$. $_" =~ /([0-9]+)[ \t]+.*{[ \t]+dg-([-a-z]+)[ \t]+(.*)[ \t]+}[^}]*(\n|$)/ )
		{
			my @line = ($1, $2, $3);
			#create an array of line infos (array of arrays)
			if($line[1] =~ /^options$/)
			{
				push @{$annotations{"extraopts"}}, $line[2];
			}
			elsif($line[1] =~ /^error$/)
			{
				$line[2] =~ s/^"(.*)"(.*)$/$1/;
				my $pattern = "[0-9]+: (fatal )?error:[^\n]*($line[2])";
				my $linenum = $line[0];
				push @{$annotations{"regex-err"}}, "(^|\n)([^\n]+(:$linenum:)[^\n]*($pattern)[^\n]*\n?)+";
			}
			elsif($line[1] =~ /^warning$/)
			{
				$line[2] =~ s/^"(.*)"(.*)$/$1/;
				my $pattern = "[0-9]+: warning:[^\n]*($line[2])";
				my $linenum = $line[0];
				push @{$annotations{"regex-warn"}}, "(^|\n)([^\n]+(:$linenum:)[^\n]*($pattern)[^\n]*\n?)+";
			}
			elsif($line[1] =~ /^bogus$/)
			{
			}
			elsif($line[1] =~ /^build$/)
			{
			}
			elsif($line[1] =~ /^excess-errors$/)
			{
			}
			elsif($line[1] =~ /^output$/)
			{
			}
			elsif($line[1] =~ /^final$/)
			{
			}
		}
	}
	#push the 2D array as a value in the hashtable
	$filetable{$file} = \%annotations;
}

sub build_hash_table {
	my ($filename) = @_;
	my $out_dirname = dirname($filename);
	my %file_content;
	open(my $fh, "<", $filename) or die "issue: $!";
	while(<$fh>)
	{
		my ($type, $src, $out, @args )  = split / /, $_;
		my $src_name = basename($src);
		my ($name, $cargs);
		chomp @args;

		# can't be that more compact ?
		$name = $src_name;
		$name =~s/\.[^\.]+$//;
		$name = "test_${name}_$.";
	
		$file_content{$name}{build}{dummy} = 1;

		if(!defined $filetable{$src})
		{
			# do greps and store it
			retrieve_file_specs($src);
		}
		if($type =~ /^executable$/)
		{
			$file_content{$name}{run}{dummy} = 1;
		}
		else
		{
			push @args, "-E" if ($type =~ /^preprocess$/);
			push @args, "-S" if ($type =~ /^assembly$/);
			push @args, "-c" if ($type =~ /^object$/);
		}
		$cargs = join(" ", @args);
		$file_content{$name} = {
			group => "GRPSERIAL",
			build => {
				files => "\@ROOTPATH\@/compilers/gcc/$src",
				cflags => "$cargs",
				sources => {
					binary => "$out"
				}
			},
			validate => {
				script => {
					path => "\@ROOTPATH\@/compilers/gcc/tools/gcc-valscript.pl"
				}
			},
		};

		$file_content{$name}{info} = $filetable{$src} if($filetable{$src});
		if (grep {/-*-save-temps/} $cargs)
		{
			$file_content{$name}{build}{cwd} = "$out_dirname";
			$file_content{$name}{run}{cwd} = "$out_dirname";
		}
	}

	DumpFile("$out_dirname/pcvs.yml.in", \%file_content) if (%file_content);
}

sub check_tool
{
	my ($tool_name) = @_;
	my $tpath = qx/which $tool_name/;
	die qw('$tool_name' not found or not executable) unless ($tpath);
}

check_tool "runtest";

my $tmpdir = `mktemp -d`; chomp $tmpdir;

my @tools=('gcc', 'g++', 'gfortran');
$ENV{PCVS_CATCH_RUNTEST} = "pcvs.raw";
foreach(@tools)
{
	print "Building for $_ tool\n";
	system("runtest --tool=$_ --objdir $tmpdir --outdir $tmpdir --tool_exec $pwd/tools/bin/gcc > /dev/null 2>&1");
}

foreach(`find $pwd -type f -iname 'pcvs.raw'`)
{
	chomp;
	print "Generation for $_\n";
	build_hash_table($_);
}

system("rm -rf $tmpdir");
